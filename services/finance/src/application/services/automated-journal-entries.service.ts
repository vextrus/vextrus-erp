import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import moment from 'moment';
import { create, all } from 'mathjs';

export interface JournalEntry {
  id?: string;
  description: string;
  date: Date;
  reference: string;
  lines: JournalLine[];
  isAutoGenerated: boolean;
  templateId?: string;
  status: 'draft' | 'posted' | 'cancelled';
  createdBy: string;
  tenantId: string;
  metadata?: any;
}

export interface JournalLine {
  accountId: string;
  accountCode: string;
  accountName?: string;
  description?: string;
  debitAmount: number;
  creditAmount: number;
  costCenter?: string;
  project?: string;
  dimension1?: string;
  dimension2?: string;
  taxCode?: string;
}

export interface JournalTemplate {
  id: string;
  name: string;
  description: string;
  type: 'recurring' | 'accrual' | 'depreciation' | 'provision' | 'custom';
  frequency: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';
  dayOfMonth?: number;
  dayOfWeek?: number;
  monthOfYear?: number;
  isActive: boolean;
  startDate: Date;
  endDate?: Date;
  lastExecuted?: Date;
  nextExecution?: Date;
  lines: JournalTemplateLine[];
  calculationMethod?: 'fixed' | 'percentage' | 'formula';
  calculationFormula?: string;
  tenantId: string;
}

export interface JournalTemplateLine {
  accountCode: string;
  description: string;
  debitFormula?: string;
  creditFormula?: string;
  fixedDebit?: number;
  fixedCredit?: number;
  percentage?: number;
  costCenter?: string;
  project?: string;
}

export interface AccrualTemplate {
  id: string;
  name: string;
  description: string;
  expenseAccount: string;
  accrualAccount: string;
  amount: number;
  startDate: Date;
  endDate: Date;
  frequency: 'monthly' | 'quarterly';
  reversalRequired: boolean;
  reversalDays?: number;
  lastAccrualDate?: Date;
  tenantId: string;
}

export interface DepreciationSchedule {
  id: string;
  assetId: string;
  assetName: string;
  assetAccount: string;
  depreciationAccount: string;
  accumulatedDepreciationAccount: string;
  method: 'straight-line' | 'declining-balance' | 'units-of-production';
  cost: number;
  salvageValue: number;
  usefulLife: number; // in months
  startDate: Date;
  currentBookValue: number;
  accumulatedDepreciation: number;
  lastDepreciationDate?: Date;
  isActive: boolean;
  tenantId: string;
}

export interface ProvisionTemplate {
  id: string;
  name: string;
  type: 'bad-debt' | 'warranty' | 'legal' | 'restructuring' | 'custom';
  calculationMethod: 'percentage' | 'fixed' | 'aging' | 'statistical';
  baseAmount?: number;
  percentage?: number;
  expenseAccount: string;
  provisionAccount: string;
  frequency: 'monthly' | 'quarterly' | 'yearly';
  lastCalculationDate?: Date;
  tenantId: string;
}

@Injectable()
export class AutomatedJournalEntriesService {
  private readonly logger = new Logger(AutomatedJournalEntriesService.name);
  private readonly math = create(all, { number: 'number' });

  constructor(
    private readonly eventEmitter: EventEmitter2,
    // @InjectRepository(JournalTemplate)
    // private templateRepository: Repository<JournalTemplate>,
    // @InjectRepository(AccrualTemplate)
    // private accrualRepository: Repository<AccrualTemplate>,
    // @InjectRepository(DepreciationSchedule)
    // private depreciationRepository: Repository<DepreciationSchedule>,
    // @InjectRepository(ProvisionTemplate)
    // private provisionRepository: Repository<ProvisionTemplate>,
  ) {}

  // Run daily at midnight
  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  async processScheduledEntries(): Promise<void> {
    this.logger.log('Processing scheduled journal entries');

    try {
      await Promise.all([
        this.processRecurringEntries(),
        this.processAccruals(),
        this.processDepreciation(),
        this.processProvisions(),
      ]);

      this.logger.log('Scheduled journal entries processed successfully');
    } catch (error) {
      this.logger.error('Failed to process scheduled entries', error);
    }
  }

  async processRecurringEntries(): Promise<JournalEntry[]> {
    const today = new Date();
    const templates = await this.getActiveTemplates(today);
    const entries: JournalEntry[] = [];

    for (const template of templates) {
      if (this.shouldExecuteTemplate(template, today)) {
        const entry = await this.createEntryFromTemplate(template, today);
        entries.push(entry);

        // Update template's last executed date
        await this.updateTemplateExecution(template, today);
      }
    }

    this.logger.log(`Created ${entries.length} recurring journal entries`);
    return entries;
  }

  private async getActiveTemplates(date: Date): Promise<JournalTemplate[]> {
    // Mock implementation - replace with actual repository call
    return [
      {
        id: 'template-001',
        name: 'Monthly Rent',
        description: 'Office rent payment',
        type: 'recurring',
        frequency: 'monthly',
        dayOfMonth: 1,
        isActive: true,
        startDate: new Date('2024-01-01'),
        lines: [
          {
            accountCode: '6010',
            description: 'Office Rent Expense',
            fixedDebit: 50000,
            costCenter: 'ADMIN-001',
          },
          {
            accountCode: '2010',
            description: 'Accounts Payable',
            fixedCredit: 50000,
          },
        ],
        tenantId: 'default',
      },
      {
        id: 'template-002',
        name: 'Monthly Salary Accrual',
        description: 'Salary accrual entry',
        type: 'accrual',
        frequency: 'monthly',
        dayOfMonth: 25,
        isActive: true,
        startDate: new Date('2024-01-01'),
        lines: [
          {
            accountCode: '5020',
            description: 'Salary Expense',
            fixedDebit: 1000000,
            costCenter: 'ALL',
          },
          {
            accountCode: '2020',
            description: 'Accrued Salaries',
            fixedCredit: 1000000,
          },
        ],
        tenantId: 'default',
      },
    ];
  }

  private shouldExecuteTemplate(template: JournalTemplate, date: Date): boolean {
    // Check if template should be executed today
    const today = moment(date);

    // Check if within date range
    if (moment(template.startDate).isAfter(today)) return false;
    if (template.endDate && moment(template.endDate).isBefore(today)) return false;

    // Check if already executed today
    if (template.lastExecuted &&
        moment(template.lastExecuted).isSame(today, 'day')) {
      return false;
    }

    // Check frequency
    switch (template.frequency) {
      case 'daily':
        return true;

      case 'weekly':
        return today.day() === (template.dayOfWeek || 1);

      case 'monthly':
        const dayOfMonth = template.dayOfMonth || 1;
        // Handle month-end dates
        if (dayOfMonth > 28) {
          return today.date() === today.daysInMonth() ||
                 today.date() === dayOfMonth;
        }
        return today.date() === dayOfMonth;

      case 'quarterly':
        const quarterMonth = [0, 3, 6, 9].includes(today.month());
        const quarterDay = today.date() === (template.dayOfMonth || 1);
        return quarterMonth && quarterDay;

      case 'yearly':
        const yearMonth = today.month() === (template.monthOfYear || 0);
        const yearDay = today.date() === (template.dayOfMonth || 1);
        return yearMonth && yearDay;

      default:
        return false;
    }
  }

  private async createEntryFromTemplate(
    template: JournalTemplate,
    date: Date
  ): Promise<JournalEntry> {
    const lines: JournalLine[] = [];

    for (const templateLine of template.lines) {
      const line: JournalLine = {
        accountId: this.getAccountId(templateLine.accountCode),
        accountCode: templateLine.accountCode,
        description: templateLine.description,
        debitAmount: 0,
        creditAmount: 0,
        costCenter: templateLine.costCenter,
        project: templateLine.project,
      };

      // Calculate amounts based on template configuration
      if (templateLine.fixedDebit) {
        line.debitAmount = templateLine.fixedDebit;
      } else if (templateLine.debitFormula) {
        line.debitAmount = await this.evaluateFormula(templateLine.debitFormula, date);
      }

      if (templateLine.fixedCredit) {
        line.creditAmount = templateLine.fixedCredit;
      } else if (templateLine.creditFormula) {
        line.creditAmount = await this.evaluateFormula(templateLine.creditFormula, date);
      }

      lines.push(line);
    }

    const entry: JournalEntry = {
      description: `${template.description} - ${moment(date).format('MMMM YYYY')}`,
      date: date,
      reference: `AUTO-${template.id}-${moment(date).format('YYYYMMDD')}`,
      lines,
      isAutoGenerated: true,
      templateId: template.id,
      status: 'draft',
      createdBy: 'SYSTEM',
      tenantId: template.tenantId,
      metadata: {
        templateName: template.name,
        templateType: template.type,
        frequency: template.frequency,
      },
    };

    // Save the journal entry
    await this.saveJournalEntry(entry);

    // Emit event
    this.eventEmitter.emit('journal.auto.created', {
      entryId: entry.id,
      templateId: template.id,
      amount: this.calculateTotalDebits(lines),
      date: date,
    });

    return entry;
  }

  private getAccountId(accountCode: string): string {
    // Mock implementation - replace with actual account lookup
    return `account-${accountCode}`;
  }

  private async evaluateFormula(formula: string, date: Date): Promise<number> {
    // Safe formula evaluation using mathjs parser
    // Validates formula before evaluation to prevent code injection

    // Validate formula contains only allowed characters
    const allowedPattern = /^[0-9+\-*/.()MONTHYEARDAYS_IN\[\] ]+$/i;
    if (!allowedPattern.test(formula)) {
      this.logger.error(`Invalid formula: contains disallowed characters - ${formula}`);
      throw new Error('Invalid formula: contains disallowed characters');
    }

    // Prepare formula by replacing template variables
    let processedFormula = formula;
    processedFormula = processedFormula.replace(/\[MONTH\]/g, (date.getMonth() + 1).toString());
    processedFormula = processedFormula.replace(/\[YEAR\]/g, date.getFullYear().toString());
    processedFormula = processedFormula.replace(/\[DAY\]/g, date.getDate().toString());
    processedFormula = processedFormula.replace(/\[DAYS_IN_MONTH\]/g, moment(date).daysInMonth().toString());

    // Define allowed scope (no access to functions or system variables)
    const scope = {
      MONTH: date.getMonth() + 1,
      YEAR: date.getFullYear(),
      DAY: date.getDate(),
      DAYS_IN_MONTH: moment(date).daysInMonth(),
    };

    try {
      // Use mathjs safe evaluation (no eval, no code execution)
      const result = this.math.evaluate(processedFormula, scope);

      // Ensure result is a valid number
      if (typeof result !== 'number' || !isFinite(result)) {
        this.logger.error(`Formula evaluation returned invalid number: ${result}`);
        return 0;
      }

      return result;
    } catch (error) {
      this.logger.error(`Failed to evaluate formula: ${formula}`, error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Formula evaluation failed: ${errorMessage}`);
    }
  }

  private async saveJournalEntry(entry: JournalEntry): Promise<void> {
    // Mock implementation - save to database
    entry.id = `JE-${Date.now()}`;
    this.logger.log(`Saved journal entry: ${entry.id}`);
  }

  private calculateTotalDebits(lines: JournalLine[]): number {
    return lines.reduce((sum, line) => sum + line.debitAmount, 0);
  }

  private async updateTemplateExecution(template: JournalTemplate, date: Date): Promise<void> {
    template.lastExecuted = date;
    template.nextExecution = this.calculateNextExecution(template, date);

    // Update in database
    // await this.templateRepository.update(template.id, {
    //   lastExecuted: date,
    //   nextExecution: template.nextExecution,
    // });
  }

  private calculateNextExecution(template: JournalTemplate, fromDate: Date): Date {
    const from = moment(fromDate);

    switch (template.frequency) {
      case 'daily':
        return from.add(1, 'day').toDate();

      case 'weekly':
        return from.add(1, 'week').toDate();

      case 'monthly':
        return from.add(1, 'month').toDate();

      case 'quarterly':
        return from.add(3, 'months').toDate();

      case 'yearly':
        return from.add(1, 'year').toDate();

      default:
        return from.add(1, 'month').toDate();
    }
  }

  async processAccruals(): Promise<JournalEntry[]> {
    const today = new Date();
    const accrualTemplates = await this.getActiveAccrualTemplates(today);
    const entries: JournalEntry[] = [];

    for (const template of accrualTemplates) {
      if (this.shouldProcessAccrual(template, today)) {
        const entry = await this.createAccrualEntry(template, today);
        entries.push(entry);

        // Create reversal entry if required
        if (template.reversalRequired) {
          const reversalEntry = await this.createReversalEntry(entry, template.reversalDays || 1);
          entries.push(reversalEntry);
        }
      }
    }

    this.logger.log(`Created ${entries.length} accrual entries`);
    return entries;
  }

  private async getActiveAccrualTemplates(date: Date): Promise<AccrualTemplate[]> {
    // Mock implementation
    return [
      {
        id: 'accrual-001',
        name: 'Monthly Insurance Accrual',
        description: 'Insurance expense accrual',
        expenseAccount: '6030',
        accrualAccount: '2030',
        amount: 25000,
        startDate: new Date('2024-01-01'),
        endDate: new Date('2024-12-31'),
        frequency: 'monthly',
        reversalRequired: true,
        reversalDays: 5,
        tenantId: 'default',
      },
    ];
  }

  private shouldProcessAccrual(template: AccrualTemplate, date: Date): boolean {
    const today = moment(date);

    // Check if within date range
    if (moment(template.startDate).isAfter(today)) return false;
    if (moment(template.endDate).isBefore(today)) return false;

    // Check if already processed this period
    if (template.lastAccrualDate) {
      const lastAccrual = moment(template.lastAccrualDate);

      if (template.frequency === 'monthly' &&
          lastAccrual.isSame(today, 'month')) {
        return false;
      }

      if (template.frequency === 'quarterly' &&
          lastAccrual.isSame(today, 'quarter')) {
        return false;
      }
    }

    // Process on month-end for monthly, quarter-end for quarterly
    if (template.frequency === 'monthly') {
      return today.date() === today.daysInMonth();
    }

    if (template.frequency === 'quarterly') {
      const quarterEnd = moment(today).endOf('quarter');
      return today.isSame(quarterEnd, 'day');
    }

    return false;
  }

  private async createAccrualEntry(template: AccrualTemplate, date: Date): Promise<JournalEntry> {
    // Calculate prorated amount if needed
    const amount = this.calculateAccrualAmount(template, date);

    const entry: JournalEntry = {
      description: `${template.description} - ${moment(date).format('MMMM YYYY')}`,
      date: date,
      reference: `ACCRUAL-${template.id}-${moment(date).format('YYYYMMDD')}`,
      lines: [
        {
          accountId: this.getAccountId(template.expenseAccount),
          accountCode: template.expenseAccount,
          accountName: 'Expense Account',
          description: template.description,
          debitAmount: amount,
          creditAmount: 0,
        },
        {
          accountId: this.getAccountId(template.accrualAccount),
          accountCode: template.accrualAccount,
          accountName: 'Accrual Account',
          description: template.description,
          debitAmount: 0,
          creditAmount: amount,
        },
      ],
      isAutoGenerated: true,
      status: 'draft',
      createdBy: 'SYSTEM',
      tenantId: template.tenantId,
      metadata: {
        type: 'accrual',
        templateId: template.id,
        reversalRequired: template.reversalRequired,
      },
    };

    await this.saveJournalEntry(entry);
    return entry;
  }

  private calculateAccrualAmount(template: AccrualTemplate, date: Date): number {
    // For simplicity, using fixed amount
    // In production, could calculate based on days in period, etc.
    return template.amount;
  }

  private async createReversalEntry(originalEntry: JournalEntry, daysAfter: number): Promise<JournalEntry> {
    const reversalDate = moment(originalEntry.date).add(daysAfter, 'days').toDate();

    const reversalLines: JournalLine[] = originalEntry.lines.map(line => ({
      ...line,
      debitAmount: line.creditAmount,
      creditAmount: line.debitAmount,
      description: `Reversal: ${line.description}`,
    }));

    const reversalEntry: JournalEntry = {
      description: `Reversal: ${originalEntry.description}`,
      date: reversalDate,
      reference: `REV-${originalEntry.reference}`,
      lines: reversalLines,
      isAutoGenerated: true,
      status: 'draft',
      createdBy: 'SYSTEM',
      tenantId: originalEntry.tenantId,
      metadata: {
        type: 'reversal',
        originalEntryId: originalEntry.id,
      },
    };

    await this.saveJournalEntry(reversalEntry);
    return reversalEntry;
  }

  async processDepreciation(): Promise<JournalEntry[]> {
    const today = new Date();
    const schedules = await this.getActiveDepreciationSchedules(today);
    const entries: JournalEntry[] = [];

    for (const schedule of schedules) {
      if (this.shouldProcessDepreciation(schedule, today)) {
        const entry = await this.createDepreciationEntry(schedule, today);
        entries.push(entry);

        // Update schedule
        await this.updateDepreciationSchedule(schedule, today);
      }
    }

    this.logger.log(`Created ${entries.length} depreciation entries`);
    return entries;
  }

  private async getActiveDepreciationSchedules(date: Date): Promise<DepreciationSchedule[]> {
    // Mock implementation
    return [
      {
        id: 'dep-001',
        assetId: 'asset-001',
        assetName: 'Office Equipment',
        assetAccount: '1510',
        depreciationAccount: '5080',
        accumulatedDepreciationAccount: '1520',
        method: 'straight-line',
        cost: 100000,
        salvageValue: 10000,
        usefulLife: 60, // 5 years
        startDate: new Date('2024-01-01'),
        currentBookValue: 95000,
        accumulatedDepreciation: 5000,
        isActive: true,
        tenantId: 'default',
      },
    ];
  }

  private shouldProcessDepreciation(schedule: DepreciationSchedule, date: Date): boolean {
    const today = moment(date);

    // Check if asset is still active
    if (!schedule.isActive) return false;

    // Check if book value > salvage value
    if (schedule.currentBookValue <= schedule.salvageValue) return false;

    // Check if already depreciated this month
    if (schedule.lastDepreciationDate) {
      const lastDepreciation = moment(schedule.lastDepreciationDate);
      if (lastDepreciation.isSame(today, 'month')) {
        return false;
      }
    }

    // Process on month-end
    return today.date() === today.daysInMonth();
  }

  private async createDepreciationEntry(schedule: DepreciationSchedule, date: Date): Promise<JournalEntry> {
    const depreciationAmount = this.calculateDepreciationAmount(schedule);

    const entry: JournalEntry = {
      description: `Depreciation: ${schedule.assetName} - ${moment(date).format('MMMM YYYY')}`,
      date: date,
      reference: `DEP-${schedule.id}-${moment(date).format('YYYYMMDD')}`,
      lines: [
        {
          accountId: this.getAccountId(schedule.depreciationAccount),
          accountCode: schedule.depreciationAccount,
          accountName: 'Depreciation Expense',
          description: `Monthly depreciation for ${schedule.assetName}`,
          debitAmount: depreciationAmount,
          creditAmount: 0,
        },
        {
          accountId: this.getAccountId(schedule.accumulatedDepreciationAccount),
          accountCode: schedule.accumulatedDepreciationAccount,
          accountName: 'Accumulated Depreciation',
          description: `Accumulated depreciation for ${schedule.assetName}`,
          debitAmount: 0,
          creditAmount: depreciationAmount,
        },
      ],
      isAutoGenerated: true,
      status: 'draft',
      createdBy: 'SYSTEM',
      tenantId: schedule.tenantId,
      metadata: {
        type: 'depreciation',
        assetId: schedule.assetId,
        method: schedule.method,
      },
    };

    await this.saveJournalEntry(entry);
    return entry;
  }

  private calculateDepreciationAmount(schedule: DepreciationSchedule): number {
    switch (schedule.method) {
      case 'straight-line':
        // (Cost - Salvage Value) / Useful Life
        const depreciableAmount = schedule.cost - schedule.salvageValue;
        const monthlyDepreciation = depreciableAmount / schedule.usefulLife;

        // Ensure we don't depreciate below salvage value
        const remainingDepreciable = schedule.currentBookValue - schedule.salvageValue;
        return Math.min(monthlyDepreciation, remainingDepreciable);

      case 'declining-balance':
        // Fixed percentage of current book value
        const rate = 2 / schedule.usefulLife; // Double declining balance
        const decliningAmount = schedule.currentBookValue * rate;

        // Ensure we don't go below salvage value
        const minBookValue = schedule.salvageValue;
        const maxDepreciation = schedule.currentBookValue - minBookValue;
        return Math.min(decliningAmount, maxDepreciation);

      case 'units-of-production':
        // Would need production data
        return 0;

      default:
        return 0;
    }
  }

  private async updateDepreciationSchedule(schedule: DepreciationSchedule, date: Date): Promise<void> {
    const depreciationAmount = this.calculateDepreciationAmount(schedule);

    schedule.currentBookValue -= depreciationAmount;
    schedule.accumulatedDepreciation += depreciationAmount;
    schedule.lastDepreciationDate = date;

    // Check if fully depreciated
    if (schedule.currentBookValue <= schedule.salvageValue) {
      schedule.isActive = false;
    }

    // Update in database
    // await this.depreciationRepository.update(schedule.id, schedule);
  }

  async processProvisions(): Promise<JournalEntry[]> {
    const today = new Date();
    const templates = await this.getActiveProvisionTemplates(today);
    const entries: JournalEntry[] = [];

    for (const template of templates) {
      if (this.shouldProcessProvision(template, today)) {
        const entry = await this.createProvisionEntry(template, today);
        entries.push(entry);
      }
    }

    this.logger.log(`Created ${entries.length} provision entries`);
    return entries;
  }

  private async getActiveProvisionTemplates(date: Date): Promise<ProvisionTemplate[]> {
    // Mock implementation
    return [
      {
        id: 'prov-001',
        name: 'Bad Debt Provision',
        type: 'bad-debt',
        calculationMethod: 'percentage',
        percentage: 2, // 2% of receivables
        expenseAccount: '6040',
        provisionAccount: '1530',
        frequency: 'quarterly',
        tenantId: 'default',
      },
    ];
  }

  private shouldProcessProvision(template: ProvisionTemplate, date: Date): boolean {
    const today = moment(date);

    // Check if already processed this period
    if (template.lastCalculationDate) {
      const lastCalc = moment(template.lastCalculationDate);

      if (template.frequency === 'monthly' &&
          lastCalc.isSame(today, 'month')) {
        return false;
      }

      if (template.frequency === 'quarterly' &&
          lastCalc.isSame(today, 'quarter')) {
        return false;
      }

      if (template.frequency === 'yearly' &&
          lastCalc.isSame(today, 'year')) {
        return false;
      }
    }

    // Process at period end
    if (template.frequency === 'monthly') {
      return today.date() === today.daysInMonth();
    }

    if (template.frequency === 'quarterly') {
      const quarterEnd = moment(today).endOf('quarter');
      return today.isSame(quarterEnd, 'day');
    }

    if (template.frequency === 'yearly') {
      const yearEnd = moment(today).endOf('year');
      return today.isSame(yearEnd, 'day');
    }

    return false;
  }

  private async createProvisionEntry(template: ProvisionTemplate, date: Date): Promise<JournalEntry> {
    const amount = await this.calculateProvisionAmount(template, date);

    const entry: JournalEntry = {
      description: `${template.name} - ${moment(date).format('MMMM YYYY')}`,
      date: date,
      reference: `PROV-${template.id}-${moment(date).format('YYYYMMDD')}`,
      lines: [
        {
          accountId: this.getAccountId(template.expenseAccount),
          accountCode: template.expenseAccount,
          accountName: 'Provision Expense',
          description: template.name,
          debitAmount: amount,
          creditAmount: 0,
        },
        {
          accountId: this.getAccountId(template.provisionAccount),
          accountCode: template.provisionAccount,
          accountName: 'Provision Account',
          description: template.name,
          debitAmount: 0,
          creditAmount: amount,
        },
      ],
      isAutoGenerated: true,
      status: 'draft',
      createdBy: 'SYSTEM',
      tenantId: template.tenantId,
      metadata: {
        type: 'provision',
        templateId: template.id,
        calculationMethod: template.calculationMethod,
      },
    };

    await this.saveJournalEntry(entry);
    return entry;
  }

  private async calculateProvisionAmount(template: ProvisionTemplate, date: Date): Promise<number> {
    switch (template.calculationMethod) {
      case 'percentage':
        // Would need to fetch base amount (e.g., receivables balance)
        const baseAmount = await this.getProvisionBaseAmount(template.type);
        return baseAmount * (template.percentage || 0) / 100;

      case 'fixed':
        return template.baseAmount || 0;

      case 'aging':
        // Would need aging analysis
        return await this.calculateAgingProvision(template);

      case 'statistical':
        // Would need historical data analysis
        return await this.calculateStatisticalProvision(template);

      default:
        return 0;
    }
  }

  private async getProvisionBaseAmount(type: string): Promise<number> {
    // Mock implementation - would fetch from general ledger
    switch (type) {
      case 'bad-debt':
        return 1000000; // Total receivables
      case 'warranty':
        return 5000000; // Total sales
      default:
        return 0;
    }
  }

  private async calculateAgingProvision(template: ProvisionTemplate): Promise<number> {
    // Mock aging calculation
    // In production, would analyze receivables aging
    const agingBuckets = {
      current: { amount: 500000, rate: 0 },
      '30days': { amount: 300000, rate: 2 },
      '60days': { amount: 150000, rate: 5 },
      '90days': { amount: 50000, rate: 10 },
      'over90': { amount: 10000, rate: 50 },
    };

    let provision = 0;
    for (const bucket of Object.values(agingBuckets)) {
      provision += bucket.amount * bucket.rate / 100;
    }

    return provision;
  }

  private async calculateStatisticalProvision(template: ProvisionTemplate): Promise<number> {
    // Mock statistical calculation
    // In production, would use historical loss data
    return 50000;
  }

  // Manual entry creation
  async createManualJournalEntry(data: Partial<JournalEntry>): Promise<JournalEntry> {
    // Validate journal entry
    this.validateJournalEntry(data);

    const entry: JournalEntry = {
      ...data as JournalEntry,
      id: `JE-${Date.now()}`,
      isAutoGenerated: false,
      status: data.status || 'draft',
      createdBy: data.createdBy || 'USER',
    };

    await this.saveJournalEntry(entry);

    this.eventEmitter.emit('journal.manual.created', {
      entryId: entry.id,
      amount: this.calculateTotalDebits(entry.lines),
      createdBy: entry.createdBy,
    });

    return entry;
  }

  private validateJournalEntry(data: Partial<JournalEntry>): void {
    if (!data.lines || data.lines.length === 0) {
      throw new Error('Journal entry must have at least one line');
    }

    // Check if debits equal credits
    const totalDebits = data.lines.reduce((sum, line) => sum + line.debitAmount, 0);
    const totalCredits = data.lines.reduce((sum, line) => sum + line.creditAmount, 0);

    if (Math.abs(totalDebits - totalCredits) > 0.01) {
      throw new Error(`Journal entry is not balanced. Debits: ${totalDebits}, Credits: ${totalCredits}`);
    }

    // Validate each line
    for (const line of data.lines) {
      if (!line.accountCode) {
        throw new Error('Each journal line must have an account code');
      }

      if (line.debitAmount < 0 || line.creditAmount < 0) {
        throw new Error('Debit and credit amounts must be non-negative');
      }

      if (line.debitAmount > 0 && line.creditAmount > 0) {
        throw new Error('A journal line cannot have both debit and credit amounts');
      }
    }
  }
}